[TOC]

# 创建型模式

## 工厂方法模式--

## 抽象工厂模式--

## 单利模式--

## 建造者模式---

## 原型模式---

# 结构型模式

## 适配器模式

- 当前实现类已经写好了 , 但是对外提供有些不尽人意? 那就用适配器模式吧. **它可以将一个类的接口转换成客户期望的另一个接口 .** 
- 记得它有类适配器模式和对象适配器模式之分, 前者为继承 ,  后者为组合.

## 装饰模式---

## 代理模式

### 虚拟代理

- 如果某些**对象在创建时需要消耗大量的资源** , 比如说很消耗内存 , 那么就用虚拟代理 , 他是**用一个轻型的对象来代替重型对象** , 而在真正使用到真正对象的时候 , 重型对象才会被创建 . 比如图片加载 . 

## 外观模式---

## 桥接模式

- 当出现需要动态的设置不同组合的时候可以考虑桥接模式 
- 对于有**两个变化维度（即两个变化的原因）的系统**，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。 
- 例如 **绘制矩形、圆形、椭圆、正方形，并且他们需要具有不同的颜色，如红色、绿色、蓝色等**

## 组合模式

- 为了解决树形结构但是对象不统一的问题 , 比如说Android的View控件树 , **无论是容器还是叶子都被统一视为叶子管理**

## 享元模式---

# 行为型模式

## 策略模式---

## 模板方法模式---

## 外观模式

- 如果你的某**一个功能或一个子系统**在**完成一项特定的功能时非常繁琐**,  那么就用外观模式 , 如同名字一样 , 他**对外提供一个比较好看的接口** , 封装繁琐的操作 .

## 迭代子模式----

## 责任链模式---

## 命令模式---

## 备忘录模式---

## 状态模式

- 如果代码中出现**大量与对象状态有关的条件语句**，**并且这些语句会导致代码的可维护性和灵活性变差**。不能方便的增加和删除状态。（主要适用场景）
- 如果对象的行为依赖于他的状态，**状态的改变将导致行为的变化**。（这一点跟策略模式很像）

## 访问者模式---

## 中介模式---

## 解释器模式----

